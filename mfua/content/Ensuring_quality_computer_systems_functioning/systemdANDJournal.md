> ## Логи в современном Linux — это не просто текстовые файлы, а целая экосистема для сбора, обработки и анализа событий системы и приложений.

### 1. Фундамент: systemd и журнал (Journal)

В современных дистрибутивах (начиная с RHEL/CentOS 7, Ubuntu 16.04+, Debian 8+) классическая связка **syslog + logrotate** часто заменена или дополнена системой **systemd-journald**.

#### **Что такое systemd-journald?**

Это встроенный в systemd механизм журналирования, который собирает сообщения от ядра, системных служб и приложений.

#### **Ключевые особенности и преимущества:**

*   **Бинарный формат:** В отличие от простых текстовых файлов, журнал хранится в бинарном виде (обычно в `/var/log/journal/`). Это позволяет хранить больше метаданных.
*   **Структурированность:** Каждая запись в журнале имеет набор полей:
    *   `_PID` - ID процесса
    *   `_UID` - ID пользователя
    *   `_COMM` - имя команды
    *   `_EXE` - путь к исполняемому файлу
    *   `_SYSTEMD_UNIT` - юнит systemd, которому принадлежит процесс
    *   `_MESSAGE` - непосредственно текст сообщения
    *   `_HOSTNAME`, `_BOOT_ID` и многие другие.
*   **Целостность:** Бинарный формат включает хеши для защиты от несанкционированного изменения записей.
*   **Автоматическая ротация:** Размер журнала контролируется автоматически (настраивается в `/etc/systemd/journald.conf`).
*   **Единая точка сбора:** Журнал собирает сообщения из всех источников: stdout/stderr служб, сообщения ядра (kmsg) и классические syslog-сообщения.

#### **Работа с журналом: команда `journalctl`**

Основной инструмент для просмотра логов — команда `journalctl`.

*   **Просмотр всего журнала:**
    ```bash
    journalctl
    ```
*   **Режим реального времени (как `tail -f`):**
    ```bash
    journalctl -f
    ```
*   **Просмотр логов конкретного юнита (службы):**
    ```bash
    journalctl -u nginx.service
    journalctl -u docker
    ```
*   **Фильтрация по времени:**
    ```bash
    journalctl --since "2023-10-01 09:00:00" --until "1 hour ago"
    journalctl --since yesterday
    ```
*   **Фильтрация по уровню важности (priority):**
    ```bash
    journalctl -p err          # Только ошибки
    journalctl -p warning      # Предупреждения и выше
    ```
*   **Структурированный поиск (по полям):**
    ```bash
    journalctl _PID=1234
    journalctl _SYSTEMD_UNIT=sshd.service _UID=0
    ```
*   **Показать логи только текущей загрузки:**
    ```bash
    journalctl -b
    ```
*   **Экспорт в удобные форматы:**
    ```bash
    journalctl -u nginx -o json-pretty  # Для последующего парсинга
    journalctl -o verbose               # Показать все метаданные записи
    ```

---

### 2. Классическая подсистема: rsyslog

Несмотря на мощь `systemd-journald`, классический **rsyslog** (или реже `syslog-ng`) никуда не делся и активно используется.

#### **Зачем он нужен, если есть journald?**

1.  **Постоянное хранилище:** `journald` по умолчанию может хранить журнал только до перезагрузки (в `/run/log/journal/`), хотя это настраивается. `rsyslog` же всегда пишет в постоянные файлы в `/var/log/`.
2.  **Совместимость:** Множество приложений и скриптов по-прежнему пишут напрямую в syslog.
3.  **Сетевая пересылка:** `rsyslog` отлично заточен для отправки логов на удаленный сервер (централизованное логирование).
4.  **Гибкая фильтрация и обработка:** Мощные правила (rules) позволяют сортировать сообщения по файлам на основе любых параметров.

#### **Как они взаимодействуют?**

Чаще всего `journald` работает как первоначальный сборщик, а затем перенаправляет сообщения в `rsyslog` для дальнейшей обработки и записи в файлы. Это позволяет использовать преимущества обеих систем.

#### **Ключевые файлы и директории rsyslog:**

*   **Конфигурация:** `/etc/rsyslog.conf`, `/etc/rsyslog.d/`
*   **Основные файлы логов:**
    *   `/var/log/messages` — Общие системные сообщения
    *   `/var/log/syslog` — Общие сообщения (в Debian/Ubuntu)
    *   `/var/log/auth.log` / `/var/log/secure` — Логи аутентификации и безопасности
    *   `/var/log/kern.log` — Сообщения ядра
    *   `/var/log/cron` — Логи планировщика заданий cron
    *   `/var/log/maillog` — Логи почтового сервера
    *   `/var/log/httpd/` или `/var/log/nginx/` — Директории с логами веб-серверов

---

### 3. Ротация логов: logrotate

Логи имеют свойство расти. `logrotate` — утилита для управления их размером и "возрастом".

*   **Принцип работы:** Она периодически (обычно раз в день из cron) переименовывает текущий файл лога (например, `mail.log` -> `mail.log.1`), создает новый и при необходимости сжимает старые файлы (.gz).
*   **Конфигурация:** Основной файл — `/etc/logrotate.conf`. Конфиги для конкретных сервисов лежат в `/etc/logrotate.d/`.

**Пример конфига для приложения:**
```
/var/log/my-app/*.log {
    daily           # Ротировать ежедневно
    missingok       # Не выдавать ошибку, если файл отсутствует
    rotate 7        # Хранить 7 архивных копий
    compress        # Сжимать архивы
    delaycompress   # Сжимать не сразу, а на следующий день
    notifempty      # Не ротировать пустые файлы
    create 644 root adm  # Создать новый файл с указанными правами
    postrotate      # Выполнить команду после ротации
        systemctl reload my-app.service
    endscript
}
```

---

### 4. Современные практики и тенденции

1.  **Структурированное логирование (Structured Logging):**
    *   Вместо простых строк в формате `[ERROR] Something went wrong` приложения выводят логи в структурированных форматах, в первую очередь **JSON**.
    *   `{"timestamp": "2023-10-26T12:00:00Z", "level": "ERROR", "service": "auth-api", "user_id": "12345", "message": "Failed login attempt", "ip": "192.168.1.100"}`
    *   Это сильно упрощает автоматический парсинг, фильтрацию и анализ в системах типа ELK.

2.  **Централизованное логирование:**
    *   В продакшн-средах логи с всех серверов пересылаются на единый центральный сервер (лог-сервер) или в облачный сервис.
    *   **Популярные стеки:**
        *   **ELK/Elastic Stack:** Elasticsearch (хранение и поиск), Logstash/Fluentd (сбор и обработка), Kibana (визуализация).
        *   **Loki:** От Grafana Labs, более легковесная альтернатива ELK, идеально интегрируется с Grafana.
        *   **Fluentd / Fluent Bit:** Очень популярные сборщики и агенты для пересылки логов.

3.  **Логи в контейнеризованных средах (Docker/Kubernetes):**
    *   Контейнеры по умолчанию пишут логи в **stdout/stderr**.
    *   Демон Docker (`dockerd`) перехватывает эти потоки и направляет их в свой драйвер логирования. По умолчанию это `json-file` (файлы в `/var/lib/docker/containers/.../*.json`).
    *   В Kubernetes логи подов собираются на нодах и также обычно перенаправляются в центральную систему (например, через Fluent Bit в Elasticsearch или Loki).

### Резюме для специалиста по качеству КС

Понимание современной системы логирования в Linux критически важно, потому что:

*   **Логи — это "черный ящик" системы.** Они являются первичным источником информации для расследования инцидентов, сбоев и проблем с производительностью.
*   **Объект уязвимости:** Неправильно настроенные логи (широкие права доступа, хранение паролей в логах) сами по себе являются уязвимостью.
*   **Инструмент мониторинга качества:** Анализируя логи (количество ошибок, время ответа, поведение пользователей), вы можете objectively оценивать качество функционирования КС.
*   **Комплаенс и аудит:** Для многих систем ведение логов является обязательным требованием стандартов безопасности.